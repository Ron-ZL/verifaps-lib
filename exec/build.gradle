import edu.sc.seis.launch4j.CreateXML
import edu.sc.seis.launch4j.Extract
import edu.sc.seis.launch4j.Launch4jConfiguration
import edu.sc.seis.launch4j.Launch4jPlugin
import edu.sc.seis.launch4j.Launch4jPluginExtension
import edu.sc.seis.launch4j.tasks.DefaultLaunch4jTask
import groovy.xml.MarkupBuilder
import net.sf.launch4j.Builder
import net.sf.launch4j.Log
import net.sf.launch4j.config.ConfigPersister
import org.gradle.util.GradleVersion

import java.nio.file.Paths

plugins {
    id("application")
    id "edu.sc.seis.launch4j" version "2.4.6"
}

mainClassName = "empty"

description = 'Case Studies and Executables of VerifAPS'

dependencies {
    compile project(':symbex')
    compile project(':geteta')
    compile project(':modularization')
    compile project(':aps-rvt')
    compile project(':run')
    compile project(':ide')

    compile group: 'io.github.microutils', name: 'kotlin-logging', version: '1.7.8'
    implementation 'com.github.ajalt:clikt:2.1.0'
    testCompile group: 'org.jetbrains.kotlin', name: 'kotlin-test-junit', version: '1.3.70'
}


def mainClasses = [
        "modularization"     : "edu.kit.iti.formal.automation.modularization.ModApp"
        , 'kastel-demo'      : "edu.kit.iti.formal.automation.KastelDemonstrator"
        , 'sc12f'            : "edu.kit.iti.formal.automation.Sc12f"
        , 'sc11-rev'         : "edu.kit.iti.formal.automation.SC11_rev"
        , "geteta"           : "edu.kit.iti.formal.automation.testtables.apps.Geteta"
        , 'ttprint'          : 'edu.kit.iti.formal.automation.testtables.apps.Printer'
        , 'reteta'           : 'edu.kit.iti.formal.automation.testtables.apps.RetetaApp'
        , 'ttmonitor'        : 'edu.kit.iti.formal.automation.testtables.apps.Monitor'
        , 'ttsynth'          : 'edu.kit.iti.formal.automation.testtables.apps.Synthizer'
        , 'rvt'              : "edu.kit.iti.formal.automation.rvt.RvtAps"
        , 'tt-unwind'        : "edu.kit.iti.formal.automation.rvt"
        , 'flycheck'         : "edu.kit.iti.formal.automation.Flycheck"
        , 'check'            : "edu.kit.iti.formal.automation.Check"
        , 'verifaps-versions': "edu.kit.iti.formal.util.Version"
        , "st2cpp"           : "edu.kit.iti.formal.automation.ST2CppApp"
        , "ttcov"            : "edu.kit.iti.formal.automation.testtables.apps.Coverage"
        , "ide"              : "edu.kit.iti.formal.automation.ide.Ide"
]

launch4j {
    copyConfigurable = project.copySpec { exclude('**') }
    // do not copy anything to lib/
}

mainClasses.each { a, b ->
    def t = task("createStart$a", type: CreateStartScripts) {
        group = "start-script"
        applicationName = a
        classpath = startScripts.classpath
        outputDir = startScripts.outputDir
        mainClassName = b
        /*startScripts.classpath.files.each {
            c -> println(c)
        }*/
    }
    applicationDistribution.from(t) { into("bin") }
    t.dependsOn startScripts


    def exe = task("createExe$a", type: edu.sc.seis.launch4j.tasks.Launch4jLibraryTask) {
        group "start-script"
        copyConfigurable = [] // do not copy anything to lib/
        productName = a
        mainClassName = b
        outfile = "${a}.exe"
        headerType = "console"
        dontWrapJar = true
        jar = ""
        chdir = ".."
        classpath = startScripts.classpath.collect{"lib/"+it.getName()}
        println(classpath)
    }
    applicationDistribution.from(exe) { into("bin") exclude("lib/") }
    exe.dependsOn startScripts
}

applicationDistribution.into("bin") {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
/*    from(createScriptKastelDemonstrator)
    from(createScriptSc12f)
    from(createScriptSc11_rev)*/
    fileMode = 0755
}

class MyL4J extends edu.sc.seis.launch4j.tasks.Launch4jLibraryTask {

    @TaskAction
    def run() {
        Extract.binaries(project)
        createExecutableFolder()
        if (GradleVersion.current() < GradleVersion.version('3.0')) {
            System.setProperty('javax.xml.parsers.DocumentBuilderFactory', 'com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl')
            System.setProperty('javax.xml.parsers.SAXParserFactory', 'com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl')
        }
        createXML(copyLibraries())
        File xml = getXmlFile()
        println(xml.text)
        ConfigPersister.getInstance().load(xml)
        Builder b = new Builder(new GradleLogger(project.logger),
                new File(project.buildDir, Launch4jPlugin.LAUNCH4J_BINARY_DIRECTORY))
        b.build()
        if (project.hasProperty("l4j-debug")) {
            new File(temporaryDir, xml.name).text = xml.text
        }
        project.delete(xml)
    }

    protected void createXML(FileCollection copySpec) {
        new MyCreateXML().execute(getXmlFile(), this, copySpec)
    }


    private static class GradleLogger extends Log {

        private Logger logger

        GradleLogger(Logger logger) {
            this.logger = logger
        }

        @Override
        void clear() {
            // nothing to do here
        }

        @Override
        void append(String line) {
            logger.info("Launch4j", line)
        }
    }
}

class MyCreateXML {
    void execute(Launch4jPluginExtension l4j) {
        execute(l4j.getXmlFile(), l4j, null)
    }

    void execute(File xmlFile, Launch4jConfiguration config, FileCollection copySpec) {
        def outputDir = config.getOutputDirectory()
        outputDir.mkdirs()
        def outFilePath = config.getDest().parentFile.toPath()
        def classpath
        if (config.classpath) {
            classpath = config.classpath
        } else if (copySpec instanceof FileCollection) {
            classpath = copySpec.collect {
                outFilePath.relativize(it.toPath()).toString()
            }
        } else {
            classpath = (copySpec ?: (project.plugins.hasPlugin('java') ? project.configurations.runtime : [])).collect {
                outFilePath.relativize(outputDir.toPath().resolve(Paths.get(config.libraryDir, it.name))).toString()
                // relativize paths relative to outfile
            }
        }
        println(classpath)
        def jar = "" //config.dontWrapJar ? outFilePath.relativize(outputDir.toPath().resolve(Paths.get(config.jar))) : config.jar
        def writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(xmlFile), "UTF-8"));
        def xml = new MarkupBuilder(writer)
        xml.mkp.xmlDeclaration(version: "1.0", encoding: "UTF-8")
        xml.launch4jConfig() {
            xml.dontWrapJar(config.dontWrapJar)
            xml.headerType(config.headerType)
            xml.jar(jar)
            xml.outfile(config.outfile)
            xml.errTitle(config.errTitle)
            xml.cmdLine(config.cmdLine)
            xml.chdir(config.chdir)
            xml.priority(config.priority)
            xml.downloadUrl(config.downloadUrl)
            xml.supportUrl(config.supportUrl)
            xml.stayAlive(config.stayAlive)
            xml.restartOnCrash(config.restartOnCrash)
            xml.manifest(config.manifest)
            xml.icon(relativizeIfAbsolute(outFilePath, config.icon))
            config.variables.each { var -> xml.var(var) }
            if (config.mainClassName) {
                xml.classPath() {
                    mainClass(config.mainClassName)
                    classpath.each() { val -> xml.cp(val) }
                }
            }
            jre() {
                xml.path(config.bundledJrePath != null ? config.bundledJrePath : "")
                xml.bundledJre64Bit(config.bundledJre64Bit)
                xml.bundledJreAsFallback(config.bundledJreAsFallback)
                def minVersion = config.jreMinVersion == null && config.bundledJrePath != null ? "" : config.jreMinVersion ? config.jreMinVersion : config.internalJreMinVersion()
                xml.minVersion(minVersion)
                xml.maxVersion(config.jreMaxVersion != null ? config.jreMaxVersion : "")
                xml.jdkPreference(config.jdkPreference)
                xml.runtimeBits(config.jreRuntimeBits)

                config.jvmOptions.each { opt ->
                    if (opt) {
                        xml.opt(opt)
                    }
                }

                if (config.initialHeapSize != null)
                    xml.initialHeapSize(config.initialHeapSize)

                if (config.initialHeapPercent != null)
                    xml.initialHeapPercent(config.initialHeapPercent)

                if (config.maxHeapSize != null)
                    xml.maxHeapSize(config.maxHeapSize)

                if (config.maxHeapPercent != null)
                    xml.maxHeapPercent(config.maxHeapPercent)
            }
            if (config.splashFileName != null && config.splashTimeout != null) {
                splash() {
                    xml.file(relativizeIfAbsolute(outFilePath, config.splashFileName))
                    xml.waitForWindow(config.splashWaitForWindows)
                    xml.timeout(config.splashTimeout)
                    xml.timeoutErr(config.splashTimeoutError)
                }
            }
            versionInfo() {
                xml.fileVersion(parseDotVersion(config.version))
                xml.txtFileVersion(config.textVersion)
                xml.fileDescription(config.fileDescription)
                xml.copyright(config.copyright)
                xml.productVersion(parseDotVersion(config.version))
                xml.txtProductVersion(config.textVersion)
                xml.productName(config.productName)
                xml.companyName(config.companyName)
                xml.internalName(config.internalName)
                xml.originalFilename(config.outfile)
                xml.trademarks(config.trademarks)
                xml.language(config.language)
            }

            if (config.messagesStartupError != null ||
                    config.messagesBundledJreError != null ||
                    config.messagesJreVersionError != null ||
                    config.messagesLauncherError != null
                    || config.messagesInstanceAlreadyExists != null
            ) {
                messages() {
                    if (config.messagesStartupError != null)
                        xml.startupErr(config.messagesStartupError)
                    if (config.messagesBundledJreError != null)
                        xml.bundledJreErr(config.messagesBundledJreError)
                    if (config.messagesJreVersionError != null)
                        xml.jreVersionErr(config.messagesJreVersionError)
                    if (config.messagesLauncherError != null)
                        xml.launcherErr(config.messagesLauncherError)
                    if (config.messagesInstanceAlreadyExists != null)
                        xml.instanceAlreadyExistsMsg(config.messagesInstanceAlreadyExists)
                }
            }
            if (config.mutexName != null || config.windowTitle != null) {
                singleInstance() {
                    if (config.mutexName != null)
                        xml.mutexName(config.mutexName)

                    if (config.windowTitle != null)
                        xml.windowTitle(config.windowTitle)
                }
            }
        }
        writer.close()
    }

    /**
     * Relativizes the other path from the source path if, and only if, it is absolute.
     *
     * @param source The source path to relativize from.
     * @param other the path to relativize against the source path.
     * @return the resulting relative path, or an empty path if both paths are equal
     * @see java.nio.file.Path#relativize(java.nio.file.Path)
     */
    static String relativizeIfAbsolute(java.nio.file.Path source, String other) {
        def path = Paths.get(other)
        if (path.absolute) {
            path = source.relativize(path)
        }
        return path
    }

    /**
     * launch4j fileVersion and productVersion are required to be x.y.z.w format, no text like beta or
     * SNAPSHOT. I think this is a windows thing. So we check the version, and if it is only dots and
     * numbers, we use it. If not we use 0.0.0.1
     * @param version
     * @return
     */
    static String parseDotVersion(version) {
        if (version ==~ /\d+(\.\d+){3}/) {
            return version
        } else if (version ==~ /\d+(\.\d+){0,2}/) {
            def s = version + '.0'
            while (s ==~ /\d+(\.\d+){0,2}/) {
                s = s + '.0'
            }
            return s
        } else {
            return '0.0.0.1'
        }
    }
}
